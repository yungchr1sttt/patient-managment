# __**Приветствую тебя, случайный прохожий!**__

Сегодня я хочу познакомить тебя со структурой своего проекта и показать, какие технологии я использовал и какие задачи решал.

_______

## Технологии, использованные в проекте

- **Docker**: Контейнеризация всех сервисов для удобства развертывания и управления зависимостями.
- **PostgreSQL**: База данных для хранения информации о пользователях.
- **Spring Boot**: Написание микросервисов с использованием фреймворка Spring Boot.
- **API Gateway**: Обеспечивает единый вход для всех микросервисов и управляет маршрутизацией.
- **Kafka**: Используется для обработки событий в реальном времени и обмена сообщениями между микросервисами.
- **gRPC**: Для высокопроизводительных удалённых вызовов между микросервисами.
- **JWT (JSON Web Tokens)**: Для аутентификации и авторизации пользователей.

_______

# Patient-Service

## Обзор 
Микросервис `patient-service` предназначен для управления данными пациентов. Он предоставляет API для получения информации о пациентах, добавления новых пациентов, обновления данных и удаления пациентов. Этот сервис взаимодействует с другими сервисами через **gRPC** и **Kafka**, а также использует базу данных для хранения данных пациентов.

## Функциональность

### Получение информации о пациентах

- **Метод**: `GET /patients`
- **Описание**: Возвращает список всех пациентов, хранящихся в базе данных, с их основной информацией.

### Создание нового пациента

- **Метод**: `POST /patients`
- **Описание**: Создает нового пациента. Включает валидацию данных пациента, таких как имя, email, адрес и дата рождения.
- **Особенности**: 
  - В случае успешного создания пациента, сервис интегрируется с внешним **Billing Service** через gRPC для создания учетной записи для пациента.
  - Генерация события о создании пациента, отправляемого в очередь **Kafka** для дальнейшей обработки другими сервисами.

### Обновление данных пациента

- **Метод**: `PUT /patients/{id}`
- **Описание**: Обновляет информацию о пациенте по его идентификатору. При обновлении также выполняется валидация и проверка существования пациента по email.

### Удаление пациента

- **Метод**: `DELETE /patients/{id}`
- **Описание**: Удаляет информацию о пациенте по его идентификатору.

## Взаимодействие с другими сервисами

1. **gRPC**: При создании нового пациента осуществляется вызов **Billing Service** для создания учетной записи через gRPC.
2. **Kafka**: Сервис отправляет события о создании пациента в Kafka для дальнейшей обработки другими сервисами.

## DTO и Модели

- **`PatientRequestDTO`**: Используется для получения данных о пациенте при создании или обновлении. Содержит обязательные поля:
  - `name`: Имя пациента
  - `email`: Электронная почта
  - `address`: Адрес
  - `dateOfBirth`: Дата рождения
  - `registeredDate`: Дата регистрации (обязательное для создания нового пациента)

- **`PatientResponseDTO`**: Используется для отправки данных о пациенте в ответах от API. Включает:
  - `id`: Идентификатор пациента
  - `name`: Имя пациента
  - `email`: Электронная почта
  - `address`: Адрес
  - `dateOfBirth`: Дата рождения

## Обработка ошибок

Сервис использует обработку ошибок через `GlobalExceptionHandler`:

- **`EmailAlreadyExistsException`**: Выбрасывается, если пациент с таким email уже существует.
- **`PatientNotFoundException`**: Выбрасывается, если пациент с данным id не найден.
- Валидация данных через аннотации, такие как `@NotBlank` и `@Email`, гарантирует, что все обязательные поля заполнены правильно.

## Технологии и библиотеки

- **Spring Boot**: Основной фреймворк для реализации микросервиса.
- **Hibernate**: Для работы с базой данных и маппинга данных в объектно-реляционную модель.
- **Kafka**: Для обработки событий и отправки сообщений между микросервисами.
- **gRPC**: Для взаимодействия с внешним **Billing сервисом**.
- **Swagger**: Для автоматической генерации документации API.


_________________

# `auth-service`

## Обзор

Микросервис `auth-service` отвечает за аутентификацию и авторизацию пользователей. Он предоставляет API для логина пользователей и валидации их **JWT токенов**. Микросервис использует **Spring Security** для обработки безопасности и **JWT** для создания и валидации токенов.

## Функциональность

### Логин пользователя

- **Метод**: `POST /login`
- **Описание**: При успешной аутентификации пользователя, сервис генерирует **JWT токен**, который клиент может использовать для аутентификации в дальнейшем. Токен возвращается в ответе на запрос.

### Валидация токена

- **Метод**: `GET /validate`
- **Описание**: Проверяет валидность переданного токена. Токен передается в заголовке `Authorization: Bearer <token>`. Если токен действителен, возвращается статус `200 OK`, в противном случае — `401 Unauthorized`.

## DTO и Модели

- **`LoginRequestDTO`**: Используется для запроса на логин, включая:
  - `email`: Электронная почта пользователя.
  - `password`: Пароль пользователя.

- **`LoginResponseDTO`**: Используется для отправки ответа с токеном:
  - `token`: JWT токен, используемый для аутентификации.

- **`User`**: Модель пользователя, хранящая:
  - `id`: Уникальный идентификатор пользователя.
  - `email`: Электронная почта пользователя.
  - `password`: Хэшированный пароль.
  - `role`: Роль пользователя.

## Бизнес-логика

- **Аутентификация**:
  - В процессе аутентификации сервис проверяет введенные данные (email и пароль) и, если они верны, генерирует JWT токен для пользователя.

- **Генерация JWT токена**:
  - JWT токен создается с использованием секретного ключа и включает информацию о пользователе (email и роль).

- **Валидация JWT токена**:
  - Токен проверяется на подпись и срок действия. Если токен недействителен или истек, выбрасывается ошибка.

## Обработка ошибок

- **`401 Unauthorized`**: Возвращается, если токен отсутствует, некорректен или истек.
- В случае ошибок аутентификации или неверных данных, API возвращает статус `401`.

_____________________________________________

# `api-gateway`

## Обзор

Микросервис `api-gateway` играет роль промежуточного слоя для маршрутизации запросов между различными микросервисами. Он принимает все входящие запросы и перенаправляет их к соответствующему сервису, обеспечивая балансировку нагрузки, фильтрацию запросов и проверку безопасности. В этом проекте используется **Spring Cloud Gateway** для маршрутизации и фильтрации запросов, а также для валидации **JWT токенов**.

## Функциональность

### Маршрутизация запросов:

Все запросы, поступающие на определенные пути, направляются к соответствующим микросервисам:

- **`/auth/**`**: запросы перенаправляются к сервису **auth-service**.
- **`/api/patients/**`**: запросы направляются к сервису **patient-service**.
- **`/api-docs/patients`**: запросы на документацию API перенаправляются к сервису **patient-service**.
- **`/api-docs/auth`**: запросы на документацию API перенаправляются к сервису **auth-service**.

### JWT валидация:

- Все запросы к **patient-service** проходят через фильтр, который проверяет наличие и валидность **JWT токена**. Токен передается в заголовке `Authorization: Bearer <token>`. Если токен отсутствует или недействителен, запрос отклоняется с кодом `401 Unauthorized`.

## Основные компоненты

### `application.yaml`:

Конфигурация маршрутов для **Spring Cloud Gateway**. Все входящие запросы на определенные пути перенаправляются к соответствующим микросервисам.

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: auth-service-root
          uri: http://auth-service:4005
          predicates:
            - Path=/auth/**
          filters:
            - StripPrefix=1

        - id: patient-service-root
          uri: http://patient-service:4000
          predicates:
            - Path=/api/patients/**
          filters:
            - StripPrefix=1
            - JwtValidation

        - id: api-docs-patient-route
          uri: http://patient-service:4000
          predicates:
            - Path=/api-docs/patients
          filters:
            - RewritePath=/api-docs/patients, /v3/api-docs

        - id: api-docs-auth-route
          uri: http://auth-service:4005
          predicates:
            - Path=/api-docs/auth
          filters:
            - RewritePath=/api-docs/auth,/v3/api-docs
```

____________________


# `analytics-service`

## Обзор

Микросервис `analytics-service` отвечает за обработку и анализ событий, связанных с пациентами. Этот микросервис получает данные о пациентах из других сервисов через **Kafka** и использует эти данные для выполнения бизнес-логики, связанной с аналитикой. Микросервис активно использует **Google Protocol Buffers** для сериализации и десериализации сообщений, а также взаимодействует с **Kafka** для обмена данными.

## Функциональность

### Обработка событий пациентов через Kafka:

- Микросервис использует **Kafka Consumer** для прослушивания событий, связанных с пациентами, которые отправляются в топик `patient`.
- Каждое событие содержит информацию о пациенте, такую как `patientId`, `name`, и `email`.
- Когда событие поступает, оно десериализуется с использованием **Protocol Buffers** и далее выполняется бизнес-логика, связанная с аналитикой.

### Пример события:
- **`PatientEvent`**: Содержит информацию о пациенте, такую как:
  - `patientId`: Идентификатор пациента.
  - `name`: Имя пациента.
  - `email`: Электронная почта пациента.
  - `event_type`: Тип события.

## Основные компоненты

### `KafkaConsumer`

- Это сервис, который использует аннотацию `@KafkaListener` для прослушивания топика Kafka, в котором публикуются события о пациентах.
- Когда событие поступает, оно десериализуется с использованием **Protocol Buffers** и выводится в лог для дальнейшего анализа.

____________________________

# `integration-tests`

## Обзор

Микросервис `integration-tests` предназначен для выполнения интеграционных тестов в проекте. Он проверяет корректность работы двух основных микросервисов: **auth-service** (для аутентификации пользователей) и **patient-service** (для получения данных о пациентах). Для тестирования используется библиотека **RestAssured**, которая позволяет взаимодействовать с REST API и проверять ответы.

## Функциональность

### Тестирование аутентификации (AuthIntegrationTest)

- **Цель**: Проверка работы аутентификации пользователя через **auth-service**:
  - В случае правильных данных (email и пароль) сервис должен возвращать **JWT токен** с кодом ответа `200 OK`.
  - В случае неверных данных (неправильный email или пароль) сервис должен возвращать код ответа `401 Unauthorized`.

### Тестирование доступа к пациентам (PatientIntegrationTest)

- **Цель**: Проверка доступа к данным о пациентах через **patient-service**:
  - После успешной аутентификации (получения JWT токена), сервис проверяет, что можно запросить данные о пациентах с помощью токена в заголовке запроса.
  - В случае успешной авторизации с валидным токеном, запрос к `/api/patients` должен вернуть список пациентов с кодом ответа `200 OK`.

## Основные компоненты

- **AuthIntegrationTest**: Тестирует аутентификацию пользователей через **auth-service**.
- **PatientIntegrationTest**: Тестирует доступность данных о пациентах через **patient-service** с использованием **JWT токенов**.










[Telegram](http://t.me/DuceyGuevarra)
